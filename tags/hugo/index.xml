<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hugo on 博客|ZHENG Zi&#39;ou</title>
    <link>https://orianna-zzo.github.io/tags/hugo/</link>
    <description>Recent content in Hugo on 博客|ZHENG Zi&#39;ou</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cmn-Hans</language>
    <lastBuildDate>Sat, 25 Aug 2018 22:59:59 +0800</lastBuildDate>
    
	<atom:link href="https://orianna-zzo.github.io/tags/hugo/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Blog养成记(16) 自建Hugo的TOC模板</title>
      <link>https://orianna-zzo.github.io/blog/2018-08/blog%E5%85%BB%E6%88%90%E8%AE%B016-%E8%87%AA%E5%BB%BAhugo%E7%9A%84toc%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Sat, 25 Aug 2018 22:59:59 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-08/blog%E5%85%BB%E6%88%90%E8%AE%B016-%E8%87%AA%E5%BB%BAhugo%E7%9A%84toc%E6%A8%A1%E6%9D%BF/</guid>
      <description>Table Of Content是一个十分常用的功能，这个系列的第13篇增加一个TOC侧边栏就是为了这个做准备，只不过是在静态页面上尝试想要的样式。
Hugo的Table of Content Hugo对于Table Of Content也有内建变量，可以参考这里。
在正文部分，Markdown正文中所有的标题都会自动建一个id，id为标题内容，也可以用{#your-id}来重新定义。TOC目录部分，Hugo对于这一部分渲染为&amp;lt;nav id=&amp;quot;TableOfContents&amp;quot;&amp;gt;&amp;lt;ul&amp;gt;&amp;lt;/ul&amp;gt;&amp;lt;/nav&amp;gt;，目录会连接到对应的id上。
我建立的partial模板如下：
{{ if .Params.toc }} &amp;lt;!--Grid column--&amp;gt; &amp;lt;div class=&amp;quot;col-md-2&amp;quot;&amp;gt; &amp;lt;!--Scrollspy--&amp;gt; &amp;lt;div id=&amp;quot;page-scrollspy&amp;quot; class=&amp;quot;toc-nav&amp;quot;&amp;gt; {{ .TableOfContents }} &amp;lt;/div&amp;gt; &amp;lt;!--Scrollspy--&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!--Grid column--&amp;gt; {{- end -}}  存在问题 其中，正如第13篇增加一个TOC侧边栏说的，我在baseof.html模板中规定了&amp;lt;body&amp;gt;的样式，想使用滚动监听，同样也配置了第14篇让同页滚动更平滑。
&amp;lt;body class=&amp;quot;bg-light&amp;quot; data-spy=&amp;quot;scroll&amp;quot; data-target=&amp;quot;#page-scrollspy&amp;quot; data-offset=&amp;quot;90&amp;quot;&amp;gt;  但可惜的是，由于Hugo自动渲染的html代码中缺少滚动监听所必须的类，因此无法实现滚动监听的功能。此外，Hugo的TOC对1~6级标题都包括了进来，这样光1级和6级之间的缩进空间就占了不少。因此不得不自己重新写TOC的模板。
自建TOC模板 在Github的Issue中找到了对于这些问题的一个方法，因此决定参考着也定制化地写一个我自己的TOC模板。模板中我并没有选择监听所有的标题，而只选择了&amp;lt;h1&amp;gt;~&amp;lt;h4&amp;gt;。
{{ if .Params.toc }} &amp;lt;!-- ignore empty links with + --&amp;gt; {{ $headers := findRE &amp;quot;&amp;lt;h[1-4].*?&amp;gt;(.|\n])+?&amp;lt;/h[1-4]&amp;gt;&amp;quot; .Content }} &amp;lt;!-- at least one header to link to --&amp;gt; {{ if ge (len $headers) 1 }} &amp;lt;!</description>
    </item>
    
    <item>
      <title>Blog养成记(15) 创建shortcode模板便捷高亮内容</title>
      <link>https://orianna-zzo.github.io/blog/2018-08/blog%E5%85%BB%E6%88%90%E8%AE%B015-%E5%88%9B%E5%BB%BAshortcode%E6%A8%A1%E6%9D%BF%E4%BE%BF%E6%8D%B7%E9%AB%98%E4%BA%AE%E5%86%85%E5%AE%B9/</link>
      <pubDate>Tue, 21 Aug 2018 21:59:02 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-08/blog%E5%85%BB%E6%88%90%E8%AE%B015-%E5%88%9B%E5%BB%BAshortcode%E6%A8%A1%E6%9D%BF%E4%BE%BF%E6%8D%B7%E9%AB%98%E4%BA%AE%E5%86%85%E5%AE%B9/</guid>
      <description>为什么使用shortcode 由于Hugo支持在文本内容中使用html标签，因此在文本中的文字如果需要高亮可以直接使用&amp;lt;mark&amp;gt;标签即可。但是code fence中的代码如何进行高亮呢？直接在code fence中使用html标签会被默认为文本（理应有办法转义，但暂时还不了解）。
之前我的方案是使用highlight shortcode(参见Hugo的语法高亮配置)，但是由于highlight渲染的风格难以调整的关系，对于这个使用起来非常不灵活。而且使用hightlight shortcode只能一行一行地高亮，不够灵活，有时只想高亮代码段中部分代码怎么办？
什么是shortcode模板 Hugo官网对Shortcode介绍为出现在内容文件中可以自定义的代码片段(snippets)，可以减少作者在Markdown的内容中增加大段html的标签内容。Hugo本身提供了一些内建的shortcode，比如我之前使用的highlight就是其中一个，还有一些其他常用的片段内容。
Shortcode不会在Hugo模板(template)中起作用，对应在Hugo模板中的片段应放在partial文件夹中作为partial模板。
新建shortcode改变背景色 在/layouts/shortcodes/文件夹中新建一个html文件，文件名是shortcode的代码名。
在这个场景中，我想要改变选中文字的背景色，因此我新建了bgstyle.html文件。
在该文件中写shortcode的内容：
{{- if eq (.Get 0) &amp;quot;yellow&amp;quot; -}} &amp;lt;mark style=&amp;quot;background: #ffeb92fd;&amp;quot;&amp;gt; {{- .Inner -}} &amp;lt;/mark&amp;gt; {{- else if eq (.Get 0) &amp;quot;red&amp;quot; -}} &amp;lt;mark style=&amp;quot;background: #fa9494;&amp;quot;&amp;gt; {{- .Inner -}} &amp;lt;/mark&amp;gt; {{- else if eq (.Get 0) &amp;quot;blue&amp;quot; -}} &amp;lt;mark style=&amp;quot;background: #9ccaff;&amp;quot;&amp;gt; {{- .Inner -}} &amp;lt;/mark&amp;gt; {{- else if eq (.Get 0) &amp;quot;green&amp;quot; -}} &amp;lt;mark style=&amp;quot;background: #acffea;&amp;quot;&amp;gt; {{- .</description>
    </item>
    
    <item>
      <title>Blog养成记(7) Hugo多级列表无法显示? —— Markdown的bug合集</title>
      <link>https://orianna-zzo.github.io/blog/2018-03/blog%E5%85%BB%E6%88%90%E8%AE%B07-hugo%E5%A4%9A%E7%BA%A7%E5%88%97%E8%A1%A8%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA--markdown%E7%9A%84bug%E5%90%88%E9%9B%86/</link>
      <pubDate>Tue, 20 Mar 2018 16:46:17 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-03/blog%E5%85%BB%E6%88%90%E8%AE%B07-hugo%E5%A4%9A%E7%BA%A7%E5%88%97%E8%A1%A8%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA--markdown%E7%9A%84bug%E5%90%88%E9%9B%86/</guid>
      <description>前言 又一次开始折腾Markdown了，不过这一次是因为好好的md文件，在typora中显示的好好的，但在Hugo渲染后格式就不对了，引起我这次探究主要问题在多级列表。考虑到毕竟两个软件的markdown渲染引擎不同，我并没有用到很特别的语法。之前在引用上也碰到了问题，typora中能很好地识别我想要的引用段落，但是Hugo不行。所以这次探究下是哪里出了问题，以及对应的解决方案。
既然已经提到了markdown，在针对问题之前也记录下现在hugo的markdown解析引擎。Markdown解析器有很多，最广泛应用的是GitHub Flavored Markdown的解析器(GFM)，基于CommonMark进行了拓展。Hugo现在默认使用Blackfriday作为Markdown解析引擎，只要日志文件是以.md或者.markdown结尾即可，可以参考这里在配置文件中配置相关参数。除了Blackfriday这个使用最广泛的引擎之外，hugo还支持mmark，mmark是一个基于Blackfriday之上增加了更多拓展语法的解析器。有两种方式可以声明使用mmark，一种是日志文件以.mmark结尾，另一种在日志文件的头部增加markup: mmark声明使用mmark进行解析。
问题列表 以下是问题列表：
 无序列表的多级列表无法显示层级，即应表现为:
  have a try  first second  another     却表现为(空心应为实心)：
  have a try  first second another    有序列表下的无序列表表现为有序列表，即应表现为:
  have a try  first second    却表现为：
  have a try  first second    引用中的代码段无法识别正确结束位置，即应表现为:
  In the quote
$ This is code fence   Out the quote</description>
    </item>
    
    <item>
      <title>Blog养成记(6) Hugo中的LaTeX渲染</title>
      <link>https://orianna-zzo.github.io/blog/2018-03/blog%E5%85%BB%E6%88%90%E8%AE%B06-hugo%E4%B8%AD%E7%9A%84latex%E6%B8%B2%E6%9F%93/</link>
      <pubDate>Mon, 19 Mar 2018 22:33:45 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-03/blog%E5%85%BB%E6%88%90%E8%AE%B06-hugo%E4%B8%AD%E7%9A%84latex%E6%B8%B2%E6%9F%93/</guid>
      <description>前言 Hugo本身并不支持\(\LaTeX\)，但可以通过javascript进行渲染。Hugo官网提供了多种方法，由于这篇博客我决定选择\(\KaTeX\)，而不是MathJax。
安装 在head.html的标签前加上以下语句：
&amp;lt;!-- KaTeX --&amp;gt; &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css&amp;quot; integrity=&amp;quot;sha384-TEMocfGvRuD1rIAacqrknm5BQZ7W7uWitoih+jMNFXQIbNl16bO8OZmylH/Vi/Ei&amp;quot; crossorigin=&amp;quot;anonymous&amp;quot;&amp;gt; &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.js&amp;quot; integrity=&amp;quot;sha384-jmxIlussZWB7qCuB+PgKG1uLjjxbVVIayPJwi6cG6Zb4YKq0JIw+OMnkkEC7kYCq&amp;quot; crossorigin=&amp;quot;anonymous&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/contrib/auto-render.min.js&amp;quot; integrity=&amp;quot;sha384-IiI65aU9ZYub2MY9zhtKd1H2ps7xxf+eb2YFG9lX6uRqpXCvBTOidPRCXCrQ++Uc&amp;quot; crossorigin=&amp;quot;anonymous&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; document.addEventListener(&amp;quot;DOMContentLoaded&amp;quot;, function() { renderMathInElement(document.body); }); &amp;lt;/script&amp;gt;  不过0.9.0版本似乎很难链接，还是从这里下载js和css，并放在static/js文件夹中，并将上面代码改为：
&amp;lt;!-- KaTeX --&amp;gt; &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;/js/katex/katex.min.css&amp;quot; &amp;gt; &amp;lt;script src=&amp;quot;/js/katex/katex.min.js&amp;quot; &amp;gt; &amp;lt;/script&amp;gt; &amp;lt;script src=&amp;quot;/js/katex/contrib/auto-render.min.js&amp;quot; &amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; document.addEventListener(&amp;quot;DOMContentLoaded&amp;quot;, function() { renderMathInElement(document.body); }); &amp;lt;/script&amp;gt;  使用 尽管KaTeX的github上是如下给出auto-render的默认值的：
[ {left: &amp;quot;$$&amp;quot;, right: &amp;quot;$$&amp;quot;, display: true}, {left: &amp;quot;\\[&amp;quot;, right: &amp;quot;\\]&amp;quot;, display: true}, {left: &amp;quot;\\(&amp;quot;, right: &amp;quot;\\)&amp;quot;, display: false} ]  但实际上，三种标识符都成立，其中前两种将数学公式以block形式展现，第三种以inline形式展现。使用中只需要将left和right放在数学公式两侧即可。</description>
    </item>
    
    <item>
      <title>Blog养成记(4) Hugo中增加tags等分类</title>
      <link>https://orianna-zzo.github.io/blog/2018-01/blog%E5%85%BB%E6%88%90%E8%AE%B04-hugo%E4%B8%AD%E5%A2%9E%E5%8A%A0tags%E7%AD%89%E5%88%86%E7%B1%BB/</link>
      <pubDate>Tue, 09 Jan 2018 18:22:25 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-01/blog%E5%85%BB%E6%88%90%E8%AE%B04-hugo%E4%B8%AD%E5%A2%9E%E5%8A%A0tags%E7%AD%89%E5%88%86%E7%B1%BB/</guid>
      <description>自定义分类 Hugo是支持用户自定义分类的，这个称为taxonomy，可以来对网页内容进行逻辑划分，详情可以在这里查看。
分类taxonomy有3个概念：
 Taxonomy 分类: 可以用来对内容进行分类的类别 Term 术语: 分类的一个键 Value 值: 分配给这个Term的具体内容  例如我需要增加3个分类，分别是：
 tag：文章标签 topic：文章主题/文章系列 category：文章分类  以tag为例，则对应Taxonomy是tag，Term是具体标签内容比如docker或者hugo，Value是打上这个标签的对应网页。
配置分类 需要在 config.toml 中增加分类。还是这个例子，则需要增加如下内容：
[taxonomies] tag = &amp;quot;tags&amp;quot; series = &amp;quot;series&amp;quot; category = &amp;quot;categories&amp;quot;  而将每个post的头部也相应增加对应的分类，例如这篇的头部就相应为：
date: &amp;quot;2018-01-09T16:22:25+08:00&amp;quot; draft: false title: &amp;quot;Blog养成记(4) 增加tags等分类&amp;quot; tags: [&amp;quot;hugo&amp;quot;] series: [&amp;quot;Blog养成记&amp;quot;] categories: [&amp;quot;杂技浅尝&amp;quot;]  当然实际上，Hugo默认会产生 tags 和 categories 的分类，如果只需要这两个，可以不用在 config.toml 中声明就在post头部使用。
分类集合查看 使用分类taxonomy之后，Hugo会使用分类的模板 (taxonomy templates) 来自动生成一个显示所有分类的term术语的网页以及一个显示该术语的所有value内容列表网页。
还是以tag为例：
example.com/tags/ 会列出tags中的所有术语；
example.com/tags/docker 会列出tags标为docker的所有网页列表。
分类排序  分类排序还未正式尝试，无法确认正式效果，还需后面确认后再补充。</description>
    </item>
    
    <item>
      <title>Blog养成记(3) Hugo的语法高亮配置</title>
      <link>https://orianna-zzo.github.io/blog/2018-01/blog%E5%85%BB%E6%88%90%E8%AE%B03-hugo%E7%9A%84%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Tue, 09 Jan 2018 17:52:25 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-01/blog%E5%85%BB%E6%88%90%E8%AE%B03-hugo%E7%9A%84%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E9%85%8D%E7%BD%AE/</guid>
      <description>前言 Hugo官网在这里给出了详细的语法高亮配置说明。
一般有以下几种常见方法：
1. 使用Hugo默认Chroma (弃，一些代码无法高亮)
 使用Pygments (弃，一些代码无法高亮)
 使用Highlight Shortcode (弃，高亮颜色渲染问题)
 使用Highlight.js ✔️
  使用Pygments进行高亮 Hugo从0.28版本开始默认使用Chroma来作语法高亮。Chroma使用go编写的，渲染速度很快。 如果需要使用Pygments，需要先安装Pygments，并在网站配置文件中设置一些相关参数。
Pygments安装 我在建立Hugo镜像时已经安装了Pygments，不然需要先安装Pygments。如果在Debian和Ubuntu系统中可以用下面语句安装，其他系统也可参考：
$ sudo apt-get install python3-pygments  Pygments配置 下面是我按官网在 config.toml 中配置的参数：
[highlighting] pygmentsUseClassic = true pygmentsCodeFences = true pygmentsStyle = &amp;quot;autumn&amp;quot;  其中， pygmentsUseClassic=true 说明使用Pygments来进行语法高亮；
pygmentsCodeFences=true 使在code fence中的根据设置的语言标签进行语法高亮；
pygmentsStyle=&amp;quot;autumn&amp;quot; 设置高亮的风格,可以在这里查看各高亮风格，选择最心仪的。
我选择了 autumn，下面是在code fence中的高亮示例：
#!/usr/bin/python3 from engine import RunForrestRun &amp;quot;&amp;quot;&amp;quot;Test code for syntax highlighting!&amp;quot;&amp;quot;&amp;quot; class Foo: def __init__(self, var): self.</description>
    </item>
    
    <item>
      <title>Blog养成记(2) Hugo&#43;Docker在Github上建立Blog</title>
      <link>https://orianna-zzo.github.io/blog/2018-01/blog%E5%85%BB%E6%88%90%E8%AE%B02-hugo-docker%E5%9C%A8github%E4%B8%8A%E5%BB%BA%E7%AB%8Bblog/</link>
      <pubDate>Sun, 07 Jan 2018 11:05:25 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-01/blog%E5%85%BB%E6%88%90%E8%AE%B02-hugo-docker%E5%9C%A8github%E4%B8%8A%E5%BB%BA%E7%AB%8Bblog/</guid>
      <description>Introduction 正如上一篇说的，我选择了Hugo作为静态网页生成器。Hugo是一个用go写的静态网页生成器，它被提及最多的优点就是它生成网站的速度快。此外，Hugo的安装配置看上去也并不麻烦，直接在这里选择合适的版本和环境下载对应release版并配置环境变量即可。整体来说非常方便。
在决定使用Hugo之外，我还决定用Docker来做环境配置。因为新买了mac，不愿意弄乱环境，也希望以后能够跨平台使用，方便配置，更重要的是，最近对docker感兴趣，想实践一下。Docker是一个开源的应用容器引擎，可以方便地将不同容器间的环境进行隔离，但又比虚拟机更轻量化，能更快速启动。与Docker相关的内容我会在另一个Docker系列进行详细说明，这里主要还是与建立Blog相关的使用为主。
网上使用Hugo写blog的内容很多，使用docker的也很多，但使用docker来搭建hugo编写环境并不多，我也是在一步步摸索中。那么，就跟着我一起开始尝试吧！
Hugo的docker环境配置 Docker安装 在Mac中可以使用Homebrew进行安装：
$ brew cask install docker  若是Windows或者其他操作系统，可以在这里选择你的操作系统下载相应版本进行安装并配置环境变量。
获得Hugo开发镜像 我在docker hub上查找了下，截止目前并没有官方镜像，都是用户自己建立并上传的镜像。Hugo的Github中的确有建立docker镜像的Dockerfile，但是我试了几次都未成功，最后决定建立自己的Hugo docker镜像，顺便学习下Dockerfile。
直接获得镜像 如果只想获得开发镜像，可以选择从docker hub上下载个镜像，选择还挺多，欢迎下载我建立的docker镜像，在docker hub中只有33MB，只需要在终端中输入下面的命令即可：
$ docker pull orianna/hugo  该镜像可以在docker hub中找到，点这里是在docker hub上的repo。
接下去在终端输入下面这行命令可以查看你现在有的镜像信息：
$ docker images  你可以发现orianna/hugo只有85.7MB大小.
自建镜像 或者，你可以选择自己建立镜像。如果已经获得了Hugo镜像，可以略过这一部分。
我建立Hugo docker的Dockerfile放在Github上，大家可以去参考试试。现在是v0.46版，只有85.7MB大小的镜像，后续随着开发可能会有新的变化。
将所有内容clone到当前目录：
$ git clone https://github.com/orianna-zzo/hugo-docker-dev.git  打开Dockerfile，其中HUGO_VERSION是Hugo官方的发布版本，可以选择你需要的Hugo版本进行修改。在v0.3的Dockerfile中，定义了两个挂载文件夹，一个是/hugo-site用来挂载你的Hugo源码，另一个是static-site用来定义Hugo生成静态网页的输出文件夹。
除了基础的下载Hugo执行文件和pygments高亮外，Dockerfile还定义了每次打开容器都会执行start.sh。该shell脚本只有一个作用，如果在当前文件夹中包含run.sh文件则执行该文件，若不存在则打开一个终端，在该终端内你可以自由尝试hugo命令。run.sh的作用主要是便于不用反复输入常用命令，可将常用命令直接写入其中保持注释状态，使用时只需要将要使用的命令保持正常状态即可。如果你clone了这个repository，在site-sample中包含了一个样例run.sh。(v2.0) 在这个repo的文件夹中打开终端，输入下面命令以建立镜像：
$ docker build -t orianna/hugo:0.46 -t orianna/hugo:latest .  其中-t给这个镜像打上tag。根据docker hub的要求，非官方镜像的镜像名称需要为你的docker-name/镜像名称，:后为该镜像的tag。-t可以有多个。注意不要忘记最后的.，它表示使用该文件夹中除了.dockerignore 中的其他内容作为建立镜像的上下文内容。
接下去你就可以在终端输入下面这行命令来查看镜像信息：
$ docker images  至此，你已经获得了Hugo的docker镜像了。
尝试使用Hugo 假设您clone了上文提到的内容，可以在该项目中使用下面命令启动容器来试用Hugo docker：</description>
    </item>
    
  </channel>
</rss>