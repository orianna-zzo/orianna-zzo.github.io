<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on 博客|ZHENG Zi&#39;ou</title>
    <link>https://orianna-zzo.github.io/blog/</link>
    <description>Recent content in Blog on 博客|ZHENG Zi&#39;ou</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 06 Jan 2018 02:15:26 +0800</lastBuildDate>
    
	<atom:link href="https://orianna-zzo.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Computer Graphics资源整理</title>
      <link>https://orianna-zzo.github.io/blog/2018-03/computer-graphics%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/</link>
      <pubDate>Sun, 25 Mar 2018 23:48:35 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-03/computer-graphics%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/</guid>
      <description>主要是针对Computer Animation，但现在还未入门，调研的是Computer Graphics大方向。
公开课 这里就只放有视频的课程了：
 2017 Spring (MIT) 6.837 Computer Graphics - Justin Solomon Materials 2017 Spring (MIT) 6.838 Shape Analysis - Justin Solomon Materials 2017 Spring (Utah) CS 6660 Physics-based Animation - Ladislav Kavan
 2013 Fall (Stanford) CS 205A Mathematical Methods for Robotics, Vision, and Graphics - Justin Solomon Materials 2013 Spring (Stanford) CS 468 Differential Geometry for Computer Science - Justin Solomon Materials在每个视频下面有写地址 2012 (Utah) CS 5600 Introduction To Computer Graphics - Matt Stoker 2012 Fall (UCB) CS184 Computer Graphics - Ravi Ramamoorthi Materials</description>
    </item>
    
    <item>
      <title>慢学Docker(3) Docker Hub速度蜗牛爬怎么办?</title>
      <link>https://orianna-zzo.github.io/blog/2018-03/%E6%85%A2%E5%AD%A6docker3-docker-hub%E9%80%9F%E5%BA%A6%E8%9C%97%E7%89%9B%E7%88%AC%E6%80%8E%E4%B9%88%E5%8A%9E/</link>
      <pubDate>Tue, 20 Mar 2018 23:47:17 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-03/%E6%85%A2%E5%AD%A6docker3-docker-hub%E9%80%9F%E5%BA%A6%E8%9C%97%E7%89%9B%E7%88%AC%E6%80%8E%E4%B9%88%E5%8A%9E/</guid>
      <description> 前言 其实两三个月前使用docker hub不管push还是pull虽然算不上光速但也不错。但今天修铭哥问我关于docker的使用，直接用Dockerfile建镜像不知道为什么成功不了，于是想直接pull我已经上传到docker hub中的镜像，结果就这1.3G左右的东西，下了整整一天。其中某layer就52M也能下半天。
晚上回家想下vue的docker镜像，几个四五十M的layer也慢悠悠下着，终于确定不仅仅是公司网不好，重点是docker hub的速度是变得更慢了。于是网上开始找解决方案。
解决方案 网上主要有以下几个国内镜像：
 Docker官方国内镜像 阿里云镜像 网易蜂巢 Daocloud  注意：docker版本低于1.10需要通过配置启动参数来配置镜像源，可参考这篇。
我用的是mac，只需要在docker的Preference中配置即可，可配置多个Registry mirrors：
最后点击⌈Apply&amp;amp; Restart⌋重启docker，或者在命令行执行重启。
$ service docker restart  若是其他操作系统，需要根据各镜像给出的流程操作。
Docker官方国内镜像 国内镜像地址是https://registry.docker-cn.com。详情查看官网。
不过据说最近国内官方镜像挂了，好在可以输入多个镜像地址。
阿里云镜像 登陆阿里云，访问https://cr.console.aliyun.com/#/accelerator，根据操作系统进行操作，添加镜像地址。
网易蜂巢 在镜像列表中添加http://hub-mirror.c.163.com。
Daocloud 进入注册入口注册。进入用户服务界面后，点击右上方的⌈加速器⌋：
就会打开如下网页，可以得到一个加速器地址。根据docker所在系统的操作系统跟着指令完成配置。
Daocloud在声明中提出docker加速器服务永久免费，希望不会食言。
Resource资源链接汇总： docker国内官方镜像、阿里云镜像、知乎上对docker版本小于1.10镜像配置方法、Daocloud
版本控制    Version Action Time     1.0 Init 2018-03-20    </description>
    </item>
    
    <item>
      <title>Blog养成记(7) Hugo多级列表无法显示? —— Markdown的bug合集</title>
      <link>https://orianna-zzo.github.io/blog/2018-03/blog%E5%85%BB%E6%88%90%E8%AE%B07-hugo%E5%A4%9A%E7%BA%A7%E5%88%97%E8%A1%A8%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA--markdown%E7%9A%84bug%E5%90%88%E9%9B%86/</link>
      <pubDate>Tue, 20 Mar 2018 16:46:17 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-03/blog%E5%85%BB%E6%88%90%E8%AE%B07-hugo%E5%A4%9A%E7%BA%A7%E5%88%97%E8%A1%A8%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA--markdown%E7%9A%84bug%E5%90%88%E9%9B%86/</guid>
      <description>前言 又一次开始折腾Markdown了，不过这一次是因为好好的md文件，在typora中显示的好好的，但在Hugo渲染后格式就不对了，引起我这次探究主要问题在多级列表。考虑到毕竟两个软件的markdown渲染引擎不同，我并没有用到很特别的语法。之前在引用上也碰到了问题，typora中能很好地识别我想要的引用段落，但是Hugo不行。所以这次探究下是哪里出了问题，以及对应的解决方案。
既然已经提到了markdown，在针对问题之前也记录下现在hugo的markdown解析引擎。Markdown解析器有很多，最广泛应用的是GitHub Flavored Markdown的解析器(GFM)，基于CommonMark进行了拓展。Hugo现在默认使用Blackfriday作为Markdown解析引擎，只要日志文件是以.md或者.markdown结尾即可，可以参考这里在配置文件中配置相关参数。除了Blackfriday这个使用最广泛的引擎之外，hugo还支持mmark，mmark是一个基于Blackfriday之上增加了更多拓展语法的解析器。有两种方式可以声明使用mmark，一种是日志文件以.mmark结尾，另一种在日志文件的头部增加markup: mmark声明使用mmark进行解析。
问题列表 以下是问题列表：
 无序列表的多级列表无法显示层级，即应表现为:
  have a try  first second  another     却表现为(空心应为实心)：
  have a try  first second another    有序列表下的无序列表表现为有序列表，即应表现为:
  have a try  first second    却表现为：
  have a try  first second    引用中的代码段无法识别正确结束位置，即应表现为:
  In the quote
 $ This is code fence   Out the quote</description>
    </item>
    
    <item>
      <title>Blog养成记(6) Hugo中的LaTeX渲染</title>
      <link>https://orianna-zzo.github.io/blog/2018-03/blog%E5%85%BB%E6%88%90%E8%AE%B06-hugo%E4%B8%AD%E7%9A%84latex%E6%B8%B2%E6%9F%93/</link>
      <pubDate>Mon, 19 Mar 2018 22:33:45 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-03/blog%E5%85%BB%E6%88%90%E8%AE%B06-hugo%E4%B8%AD%E7%9A%84latex%E6%B8%B2%E6%9F%93/</guid>
      <description>前言 Hugo本身并不支持\(\LaTeX\)，但可以通过javascript进行渲染。Hugo官网提供了多种方法，由于这篇博客我决定选择\(\KaTeX\)，而不是MathJax。
安装 在head.html的标签前加上以下语句：
&amp;lt;!-- KaTeX --&amp;gt; &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css&amp;quot; integrity=&amp;quot;sha384-TEMocfGvRuD1rIAacqrknm5BQZ7W7uWitoih+jMNFXQIbNl16bO8OZmylH/Vi/Ei&amp;quot; crossorigin=&amp;quot;anonymous&amp;quot;&amp;gt; &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.js&amp;quot; integrity=&amp;quot;sha384-jmxIlussZWB7qCuB+PgKG1uLjjxbVVIayPJwi6cG6Zb4YKq0JIw+OMnkkEC7kYCq&amp;quot; crossorigin=&amp;quot;anonymous&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/contrib/auto-render.min.js&amp;quot; integrity=&amp;quot;sha384-IiI65aU9ZYub2MY9zhtKd1H2ps7xxf+eb2YFG9lX6uRqpXCvBTOidPRCXCrQ++Uc&amp;quot; crossorigin=&amp;quot;anonymous&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; document.addEventListener(&amp;quot;DOMContentLoaded&amp;quot;, function() { renderMathInElement(document.body); }); &amp;lt;/script&amp;gt;  不过0.9.0版本似乎很难链接，还是从这里下载js和css，并放在static/js文件夹中，并将上面代码改为：
&amp;lt;!-- KaTeX --&amp;gt; &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;/js/katex/katex.min.css&amp;quot; &amp;gt; &amp;lt;script src=&amp;quot;/js/katex/katex.min.js&amp;quot; &amp;gt; &amp;lt;/script&amp;gt; &amp;lt;script src=&amp;quot;/js/katex/contrib/auto-render.min.js&amp;quot; &amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; document.addEventListener(&amp;quot;DOMContentLoaded&amp;quot;, function() { renderMathInElement(document.body); }); &amp;lt;/script&amp;gt;  使用 尽管KaTeX的github上是如下给出auto-render的默认值的：
[ {left: &amp;quot;$$&amp;quot;, right: &amp;quot;$$&amp;quot;, display: true}, {left: &amp;quot;\\[&amp;quot;, right: &amp;quot;\\]&amp;quot;, display: true}, {left: &amp;quot;\\(&amp;quot;, right: &amp;quot;\\)&amp;quot;, display: false} ]  但实际上，三种标识符都成立，其中前两种将数学公式以block形式展现，第三种以inline形式展现。使用中只需要将left和right放在数学公式两侧即可。</description>
    </item>
    
    <item>
      <title>每周Paper精读(1) Understanding Deep Learning Requires Rethinking Generalization</title>
      <link>https://orianna-zzo.github.io/blog/2018-03/%E6%AF%8F%E5%91%A8paper%E7%B2%BE%E8%AF%BB1-understanding-deep-learning-requires-rethinking-generalization/</link>
      <pubDate>Wed, 14 Mar 2018 10:40:55 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-03/%E6%AF%8F%E5%91%A8paper%E7%B2%BE%E8%AF%BB1-understanding-deep-learning-requires-rethinking-generalization/</guid>
      <description>前言 上周五小仓鼠说有篇论文很有意思，问我看过没，是ICLR 2017 的 Best Paper [Zhang et al. 2017]。汗颜的确很久没有关心会议论文，现在更多都是关心项目技术点方向的论文。这篇论文一看的确很有意思，而且在学术界引起了非常激烈的讨论。有些人认为论文深度不够，提出的观点在泛化的理论学界已经研究很久，更偏向于实验报告不足以Best Paper，有人说中间有些逻辑问题，也有不少人觉得是对传统理论发起进攻的flag。这引起了我的兴趣，于是替换了我最近打算实现的NER的论文作为精读系列第一篇。
论文地址：https://arxiv.org/abs/1611.03530
论文概要 作者通过一系列实验，展现出神经网络强大的拟合能力及现有的正则化方法的局限性，并提出传统机器学习中的泛化理论并不适用于深度学习，并说明即使在线性模型中，泛化理论实际上也没这么简单。
Contributions  展现神经网络的强大拟合能力
通过不同程度随机或根据一定规则修改数据集标签（部分错误的标签数据集、随机标签的数据集）及修改数据集图片（图片的像素点打乱的数据集(shuffled、random，前者根据打乱一部分像素，后者完全打乱)、根据高斯分布生成的新数据集）两种方式来进行实验，使用随机梯度下降SGD并使用相同的超参，(Figure 1)发现Inception模型在CIFAR10的各种数据集上都能100%拟合，只是不同噪声的数据集收敛速度有所不同（但也相差并没有太多），而一旦开始收敛，都能很快拟合。随机标签被认为是对数据的一次transformation，也就是说学习算法的uniform stability和训练数据的标签是独立的。
作者还提出不同于之前在&amp;rdquo;population level&amp;rdquo;对于特定function family在整个领域的表达能力，认为需要关注给定样本大小\(n\)情况下，也就是有限样本的网络的表达能力，并在文中证明2层使用ReLU作为激活函数并有\(2n+d\)参数的神经网络就已经有足够的capacity去表示\(d\)维的样本大小为\(n\)数据集。
 现有显式正则化方法的局限性
通过在真实数据集和随机标签数据集(CIFAR10、ImageNet2012)上，分别对不同的显式正则化方法(explicit regularization)进行试验，发现(Table 1&amp;amp;2)：
 random crop的数据增强方法在CIFAR10中使用不同网结构络(Inception、Alexnet)的试验中基本都能提高3%~4%的测试准确率，在ImageNet中能提高10%甚至以上。 Weight decay(\(l2\)正则化)在CIFAR10中能提高1%左右测试准确率，但有时会降低0.1% ~ 0.3%（Inception使用数据增强、MLP1层），在ImageNet中提高了6% ~ 8%（没有CIFAR10降低的对比情况）。 dropout并没有控制变量的对比试验。 即使加入了显式正则化方法(explicit regularization)，随机标签的数据集一样能有很高的拟合程度，CIFAR10都能达到99%以上，ImageNet中最低的也有87%，其他也都在90%以上。  基于以上发现，作者认为在CIFAR10上explicit regularization只提高了4% ~ 5%，在ImageNet上也只提高了18%，不算数据增强部分，在CIFAR10上提高1%，在ImageNet也有9% ~12%的提高。相比于改进网络结构，explicit regularization提高并不明显、不是必须步骤，而有些网络模型本身就具有了一定的泛化能力。此外，即使加入了正则化方法，训练集上的error还是能保持在很低的水平，作者认为显式正则化可能提高了模型的泛化能力，但对控制泛化误差不是必要的也并不足够。
 隐式正则化
Early stopping、Batch normalization尽管不是为了解决泛化问题，但都对模型的泛化有一定帮助(Figure 2)，被作者认为是implicit regularizer。通过对于线性模型中的随机梯度下降算法的研究分析及在MNIST和CIFAR10上的实验，作者提出SGD本身也是一种implicit regularizer。
但不管是显式正则化还是隐式正则化在合适地调参后能帮助提高泛化能力，但都移去后模型依旧有不错的泛化能力，所以并不是泛化的基本原因。
  争议点  泛化理论研究角度来说并无亮点贡献
主要引起研究泛化理论学者不满的主要是作者提出的对于传统机器学习算法中的泛化理论的研究实际上在泛化理论界已经有广泛的研究了（尽管作者在论文中有提到这点），而作者对于这个并没有提出更为进一步研究和思考。这也是很多人反对这篇论文作为Best Paper，甚至觉得只是一篇实验报告的原因。
 对于深度学习模型来说，显式正则化并非效果不如模型结构改进这一观点有些武断。
就如作者的实验来说，在ImageNet中所有显式正则化效果提升了18%，在CIFAR10上也有5%，这两者上的提高程度还是很巨大的，并不能得出正则化效果微弱，更无证据支撑模型结构的改进更为重要这一个结论。
  疑惑之处  到底怎样的机制可以被称为正则化？</description>
    </item>
    
    <item>
      <title>Docker for datascience: 从纠结到放弃</title>
      <link>https://orianna-zzo.github.io/blog/2018-02/docker-for-datascience-%E4%BB%8E%E7%BA%A0%E7%BB%93%E5%88%B0%E6%94%BE%E5%BC%83/</link>
      <pubDate>Tue, 06 Feb 2018 10:01:15 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-02/docker-for-datascience-%E4%BB%8E%E7%BA%A0%E7%BB%93%E5%88%B0%E6%94%BE%E5%BC%83/</guid>
      <description> 表示我是不纠结不死星人。
先是由jupyter stacks突发奇想，于是纠结于想建立属于自己的docker族系，特别是用来做数据科学&amp;amp;机器学习。想要不用Anaconda、甚至不用conda，自己按照使用习惯安装我自己需要的包、想使用最小的alpine作为基镜像，因此开始走上不归路。
想要使用bash而不是ash，想要默认调用bash，想要调用bash时能默认出现现在使用用户及现在所在文件夹。折腾了2天终于成功，dockerfile在orianna-zzo/dockerfile-repo/alpine-bash-docker，算是让我尝到一次甜头。
成功第一次，于是开始尝试在python3.6上安装我想要的包。pull了python3.6-alpine3，废了老大功夫总算在多次碰壁下把依赖都安装成功可以成功pip install想要的包。不过在查验我装了每个python包是什么作用时发现我安装了nomkl，这个包说明使用numpy时使用非mkl版本。网上一查，mkl对于intel的cpu加速还是很厉害的，于是把nomkl删了开始重新继续折腾。折腾了一圈，通过安装openblas-dev，替代mkl，但发现openBlas性能不如mkl。
然后狠下心，在alpine上直接安装。为了numpy等包装g++、gfortran，为了matplotlib装libfreetype-dev和libpng。结果发现连h5py都装不上，在pandas中无法用hdf5格式读写文件。alpine上mkl也难以安装成功，pip install也说平台不对。无奈之下舍弃alpine。
使用ubuntu:16.04，为了h5py等包装build-essential，为了numpy等包装g++、gfortran，为了matplotlib装libfreetype6-dev和libpng12-dev，为了mkl装cpio。mkl终于安心装上，然而pip install numpy后使用show_config()查看时无法连接到mkl。spacy下了源码直接build结果总是报编码错误。心累。
于是纠结了一周的环境问题，在我最后决定选择ubuntu:16.04+anaconda3落下帷幕。
嗯，我正在尝试这个，希望能够成功。
后文 果然还是无脑anaconda比较省心。只是ubuntu:16.04+anaconda3 后再安装tensorflow直接就超过3g大关，比官方镜像直接多了2g，捂脸。决定不再纠结这个，反正已经配置成功，可以正常使用。毕竟不是重点，已经浪费了好多时间，还是好好钻研算法吧！
相关的dockerfile都可以在orianna-zzo/dockerfile-repo/python-docker找到。
版本控制    Version Action Time     1.0 Init 2018-02-06   1.1 增加后文 2018-02-13    </description>
    </item>
    
    <item>
      <title>Pycharm vs Notebook</title>
      <link>https://orianna-zzo.github.io/blog/2018-01/pycharm-vs-notebook/</link>
      <pubDate>Tue, 30 Jan 2018 21:07:19 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-01/pycharm-vs-notebook/</guid>
      <description> 严格说来题目起的有些问题，pycharm是一个IDE (Integrated Development Environment)，而且在pycharm里同样也可以使用Notebook。这里主要是指传统的编程方式和Notebook交互式方式的比较和选择。这篇博客希望对那些和我一样有选择恐惧症并且非常迷茫的人有所帮助。
缘起 说起来接触python也已经一年半的时间。去年7月，哦不，应该是前年7月，刚入职才开始因为工作学习的python，首先遇到的就是IDE的选择问题。比较流行的开发工具有JetBrain的Pycharm和Jupyter Notebook。
初识 组长和组里新学习代码的小伙伴们偏爱notebook，不过我却更青睐相对于更像一个传统IDE 的Pycharm。
Pycharm就像是我们经常使用的其他语言的IDE一样 (比如说visual studio, eclipse)，集成各种调试工具，可以非常方便地在里面进行单步调试、变量监控，文档结构也非常明晰，而且也可以在pycharm里使用notebook（尽管我不在这里使用）。
我对于notebook的印象是介于传统IDE和console中间，反馈速度很快，很灵活，可以将每次中间结果进行保留。但是由于太灵活了，经常看到同事给我的notebook顺序非常紊乱，根本无从下手，难以复现，这也是导致我对notebook印象并不好的原因。此外，不确定是使用的版本配置或是其他原因，小伙伴的notebook在数据量增大时很容易奔溃，但是pycharm跑普通的python程序却很正常。基于以上原因，我并不是很理解为什么notebook会这么火。在我看来，直接一个pycharm乖乖编写python程序就很ok，想即时得到结果就在pycharm里开个console或者设个断点单步调试，在监控窗口也可以尝试各种代码是否可行，甚至可以监控运行时变量的状态和结构，非常方便、功能强大。有人给我的理由是notebook即使可见结果，对于初学者更为友好，但我觉得对我来说并不会如此。
初识，notebook很轻而易举地完败。
再顾 再次考虑了解notebook是源于新来的实习生都喜欢使用notebook，不仅仅是转专业的实习生喜欢，cs的也喜欢，网上很多教程类也都是在notebook之上，因此让我很想了解notebook到底有什么魔力让这么多人喜欢并且选择。
我问了cs专业的实习生，他给我的理由是可以很方便的记录各个小实验的方法过程和结果，notebook中可以添加markdown块，实验结果的数据和图片可以很方便进行显示，代码块和markdown块可以交叉存储，是一种更为灵活和方便的记录方式。
我在查找资料时也发现了大家对于notebook的使用方法。Stackoverflow上也有人提问如何更好地整理notebook中的代码，非常有启发性，建议参考下。
感觉上，notebook，顾名思义是记录本，也就是说它最大的功能是记录你的想法与尝试、零碎的小实验，并且notebook实际上并不简单局限于python。而使用notebook也有一些比较好的实践，我这里列举一些我觉得十分不错的，以便我后期查看：
 Notebook的代码应该整洁，也就是说随时可以做到按顺序重跑全部代码并能复现结果，实验结束后notebook可能需要重构。 建立一个很多project能够通用的utils库。可以写一份setup.py，让其他组员可以方便安装。 将大的notebook分成多个小的notebook，每个notebook最好能够符合“假设-数据-结论”的模式。一个例子是分为data preparation、data validation、exploratory plotting、simple linear model、hierachical model、 playground等，将数据准备的记过都存成本地文件，便于其他notebook引入。 每个cell最好能符合“idea-execution-output”的模式。  思考 并没有完整意义上的完美的工具，每个工具都有其最优使用场景。在这个场景不尽如意，不等于这不是一个好的工具。Pycharm是各个意义上强大的工具，但并不等于notebook没有优秀的地方。尽管常规编程、调试、上线不是notebook的强项，但对于数据科学这个领域需要多种实验查看数据结构，notebook就十分适合记录实验结果，可以验证多种想法假设。想法初步验证后，再正式重构正规编程。
Resource资源链接汇总 stackoverflow: 如何更好地整理notebook中的代码
版本控制    Version Action Time     1.0 Init 2018-01-30    </description>
    </item>
    
    <item>
      <title>Mac小白探索记(2) Finder设置</title>
      <link>https://orianna-zzo.github.io/blog/2018-01/mac%E5%B0%8F%E7%99%BD%E6%8E%A2%E7%B4%A2%E8%AE%B02-finder%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Tue, 30 Jan 2018 20:21:13 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-01/mac%E5%B0%8F%E7%99%BD%E6%8E%A2%E7%B4%A2%E8%AE%B02-finder%E8%AE%BE%E7%BD%AE/</guid>
      <description>Finder是mac的资源管理器，它的使用和配置与Windows区别还是挺多。习惯了Windows的使用使得Finder使用总觉得有些不便。配置好Finder能很大幅度提高我们的工作效率。
我会从遇到的问题着手，查找可以解决问题提高效率的解决方案。
Finder显示设置 显示隐藏文件夹 Mac系统Finder中的 /usr、/etc等文件夹都是隐藏文件，如果不进行设置用户是无法见到的。估计是因为mac用户并不是所有人都对linux的操作十分熟悉，所以把这些对于系统十分重要的文件夹都进行隐藏了，免得用户误删等操作把系统玩坏。
在terminal中输入下面命令：
$ defaults write com.apple.finder AppleShowAllFiles -bool true  然后重启Finder，在terminal 中输入：
$ killall Finder  当当当当，隐藏的文件夹就显示出来了！
显示工具栏 选择 ⌈显示⌋ &amp;gt; ⌈显示标签页栏⌋、⌈显示路径栏⌋、⌈显示边栏⌋、⌈显示预览⌋。
对工具栏自定义：⌈显示⌋ &amp;gt; ⌈自定义工具栏⌋，增加⌈新建文件夹⌋，或者还可以添加其他想要添加工具栏。
复制文件夹路径 直接快捷键 ⌘⌥C 即可。
不过需要注意的是，如果有其他程序设置了相同的快捷键可能会导致无法复制。实践中我把Spectacle中把窗口放在中央的快捷键设置取消了，因为会冲突。
快速打开Terminal 其实这部分应该算是效率工具，但是更像是针对Finder路径这一问题的解决方案，因此放在这里了。
其实还可以打开Terminal打上cd 之后直接把文件夹拖进去，就会显示文件夹的路径，或者 ⌘⌥C 复制路径到terminal，但是这样十分繁琐。
这里提供两个方案。方案一：设置快捷键，但是只能在上层文件夹中选择需要的路径的文件夹后才能打开Terminal。方案二：安装Go2Shell，可以在Finder的Toolbox中安装一个插件，非常方便。
方案一：设置快捷键 ⌈系统偏好设置⌋ &amp;gt; ⌈键盘⌋ &amp;gt; ⌈快捷键⌋ &amp;gt; ⌈服务⌋ &amp;gt; ⌈新建位于文件夹位置的终端窗口⌋。
这样在Finder中选中文件夹，双指右击，就可以在服务中看到打开终端的选项。
还可以设置快捷键，我设置了 ⌘⌥⌃T，选中文件夹后使用快捷键后即可快速打开终端。
方案二：安装Go2Shell 相比方案一，这个还是要方便高效更多。注意不要通过App Store安装，无法使用，直接通过Homebrew安装：
$ brew cask install go2shell  安装后打开，点击⌈Install Go2Shell to Finder⌋
然后就可以在Finder的工具栏发现Go2Shell的图标了。点击这个图标就会打开一个在当前文件夹的Terminal，很方便。</description>
    </item>
    
    <item>
      <title>Mac小白探索记(1) 基本设置与常用软件</title>
      <link>https://orianna-zzo.github.io/blog/2018-01/mac%E5%B0%8F%E7%99%BD%E6%8E%A2%E7%B4%A2%E8%AE%B01-%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE%E4%B8%8E%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/</link>
      <pubDate>Tue, 30 Jan 2018 15:04:48 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-01/mac%E5%B0%8F%E7%99%BD%E6%8E%A2%E7%B4%A2%E8%AE%B01-%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE%E4%B8%8E%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/</guid>
      <description>序 原本打算将所有相关内容只写在一篇博文里，但后面发现越加越多，内容越来越零散，最后决定进行拆分，也变为一个系列。我是2017年底才刚开始深入使用mac，算是mac小白一枚，在探索的过程中想将一些我觉得高效实用的信息记录下来，希望其他和我一样刚开始学习mac的小伙伴们能看了后有所帮助。
第一篇主要介绍新入手mac后的基本设置与常用软件安装。终于转到有terminal的电脑上了，既然换了Mac OS，需要重新开始找软件。Windows上的软件安装习惯是网上找软件exe，下载安装，基本一个版本能用很久，没有习惯更是懒得经常更新。Linux上倒是有包管理器，但用的不多，只在编程时用过，不过编程包依赖特别重要，一般不会修改，因此基本没有鼓捣过。这次准备换电脑，看着同事非常优雅自如地更新软件，有些羡慕呀，这样才能最大化开源/更新频繁的软件优势。App Store倒是可以随时更新，不过不是所有软件都发布在App Store上，所以这里记录下我需要的配置、计划安装的软件，以及安装方法，以供参照。PS，不定期更新。
首先说明下按键符号，如果第一次使用mac可能会有些混，因此这里说明一下：
⌘ - command
⌥ - option
⌃ - control
⇧ - shift
␣ - space
Windows平台上control在快捷键中使用频繁，而转到mac平台后很多通用快捷键设置需要替代为⌘command，比如⌘C复制、⌘V粘贴，快捷键会在其他文中详述。
Mac系统基本配置 触摸板设置 触摸板是mac最常用的工具，更好地设置触摸板使用起来可以方便省力很多。
⌈系统偏好设置⌋ &amp;gt; ⌈触控板⌋ ，建议将所有手势都选上，使用起来很方便，也可以节省快捷键。我常用的手势有：轻点代替点按、双指点按代表右击、三指点按选词查询词典、四指合拢打开Lauchpad、四指分开显示桌面 、三指向上划mission control。
Touchbar设置 ⌈系统偏好设置⌋ &amp;gt; ⌈键盘⌋ &amp;gt; ⌈键盘⌋ &amp;gt; 点击⌈自定义控制条⌋ 即可进行设置。
可以将一些找起来比较麻烦但常用的设置放在touchbar，移除默认设置touchbar中一些不常用的功能。我放了night shift、免打扰和屏幕保护程序。应用程序中的touchbar的功能和该应用程序本身功能有关，有些可以在程序中设置touchbar的功能。
此外有很多人推荐的BetterTouchTool也可以，不过这款软件收费。
第三方软件安装 有些软件并没有在apple认可的开发者列表内，如果要安装，首先需要mac允许软件来自任何人，而这个估计因为安全问题，属于隐藏设置，需要先打开terminal，输入：
$ sudo spctl --master-disable  然后在⌈系统偏好设置⌋ &amp;gt; ⌈安全与隐私⌋ 中选择 ⌈任何来源⌋。安装完毕后，为了安全考虑，最好能够再选择回来自可信任的开发者。
包管理器 Homebrew Mac OS用户大多使用Homebrew作为包管理工具，据说相当于Ubuntu下的apt-get。官网上的一句话介绍是 ⌈The missing package manager for macOS⌋，也就是针对Mac OS所开发的包管理器。
Homebrew官网给出了安装brew的方法，只要复制下面脚本在terminal中粘贴执行就安装成功。
$ /usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.</description>
    </item>
    
    <item>
      <title>Blog养成记(5) 要让Github Pages被索引到</title>
      <link>https://orianna-zzo.github.io/blog/2018-01/blog%E5%85%BB%E6%88%90%E8%AE%B05-%E8%A6%81%E8%AE%A9github-pages%E8%A2%AB%E7%B4%A2%E5%BC%95%E5%88%B0/</link>
      <pubDate>Sun, 28 Jan 2018 22:04:23 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-01/blog%E5%85%BB%E6%88%90%E8%AE%B05-%E8%A6%81%E8%AE%A9github-pages%E8%A2%AB%E7%B4%A2%E5%BC%95%E5%88%B0/</guid>
      <description>居然都找不到！ 其实Blog我主要是用来做一些记录，更何况忙起来经常不更新，因此尽管有加上一些流量统计的功能，但实际上也不怎么关心到底有多少访问量。在浏览网上其他人的博客布局寻找灵感时，突然看到有博客提到GitHub Pages屏蔽了百度的爬虫，所以百度是搜索不到GitHub Pages上的网页的。
什么？所以百度搜索搜不到我的个人博客？不死心，尝试一下，找得到github、gist主页，但是就是找不到github.io后缀的网页。除了百度之外，我还尝试了Bing、Google，都没有，所以常用的三大搜索引擎都找不到我的博客，小小网站在浩瀚的网络世界中就像是一个孤岛，只有知道url才能达到。突然想到传说中的暗网是否也是加上了反爬，所以大众难以发现？
话说回来，反爬也有反爬的好处，比如有时博客内容特别个人，只是想找个地方发泄一下、记录一下，不被搜索引擎索引到也降低了被他人发现的几率，就像是一个打开的日记本，但是不用担心被家长偷看的感觉。
如何让搜索引擎索引到呢？ 发现流行的搜索引擎居然都找不到博客，那就需要赶紧找解决方法。Google和Bing还不清楚是怎么回事，但网上流传的email回复内容都点明了Github Pages禁止了百度爬虫的爬去，似乎原因是百度爬虫爬得太过于频繁，会严重影响服务器性能。针对百度爬虫的问题，大家找了很多方法。比较早期的有把放在GitHub上的代码同时push到国内的GitCafe上，但GitCafe已经被Coding.net收购，2017年6月前很多方案都是同步推送到Coding.net上，而8月开始免费的Coding.net用户会被强行加入5s等待页面，也会导致爬取失败。自建服务器托管博客、将博客放在Gitlab上或者CDN方法都不在我的选择范围内，因为暂时我还没有购买服务器或者域名的打算，所以决定放弃百度……但不管怎么样Bing和Google还是要设置好的！
居然在robots.txt中设置了屏蔽!!! 我对网络、网站这部分并不熟悉，之前在了解themes里内容时有看见过这么个小小的txt文件，并没有放在心上，但原来各个爬虫爬不到罪魁祸首就在这个txt文件上。
robots.txt在网站的根目录里，文件中明确了爬虫可以爬取以及禁止收录的范围。搜索引擎爬取网站第一个访问的文件就是robots.txt。robots.txt中可以对于不同的搜索引擎机器人设置不同的权限，这里就不赘述了，毕竟也不是我关心的重点^-^。
Hugo在static文件夹中就有一个robots.txt，生成静态网页时就会把这个文件放在网站的根目录下。默认的robots.txt如下所示：
User-agent: * Disallow: /  第二行把所有爬虫都给屏蔽了，只需要把第二行的 / 删去就ok了。
尽管已经修正了robots.txt，但是过了一天多看各个搜索引擎，还是找不到我的博客网站，所以还是要进一步处理。
Google 添加资源 在google搜索页面输入“site:orianna-zzo.github.io”就可以看到这个网页是否被google索引到，如果没被索引到，在搜索结果页面就会直接提示你使用Google Search Console。登录后，如果是首次使用在Search Console中以下界面中选择“网页”类型资源，并将博客完整url填入其中，我填入“https://orianna-zzo.github.io”。注意http或者https，www等最好能完全正确。
如果已经添加过资源，则需要点击下面的红色按钮“添加属性”，然后和上面一样地添加资源即可。
资源添加后，需要验证你对该网站有所有权。Google提供了几种方法，我选择了HTML验证文件上传，只需要根据要求，下载HTML验证文件，把文件放在网站的repository中上传，然后进行验证即可。
查看robots.txt 资源添加后，先查看robots.txt是否设置正确。我就是在这里才发现在这个文档中把所有搜索引擎的爬虫机器人都屏蔽了。
进入资源后，在左侧点击“抓取&amp;gt;robots.txt测试工具”，右边会有显示robots.txt的内容。需要注意的是，robots.txt并不一定是最新版的，看上去这个每天只会更新一次。可以在下方输入需要测试的网址，并点击测试。若显示已允许则说明设置ok。
添加url robots.txt设置成功还是不够的，还是需要手动添加url。在左侧点击“抓取&amp;gt;Google抓取工具”，在右侧金融人机身份验证后，可以将想要添加的url写入输入框，并进行抓取。
状态显示完成，说明该网页已经爬取成功。点击“请求输入索引”，会显示以下选择框：
有两个选项，第一个仅抓取次网址，每个月500次提交机会，第二个抓取次网址及其直接链接，每个月有10次提交机会。提交后，编入了索引，等上一会就可以在google上搜索了！
不过提交次数多就需要进行图片验证，而且如果网站有修改就需要重新提交。鉴于现在内容不多，先都是人肉提交的，如果网页多的话，可以通过站点地图进行提交。
站点地图 在左侧点击“站点地图”，并在右侧点添加/测试站点地图，并添加url，我的是“https://orianna-zzo.github.io/sitemap.xml”。
发现提示有警告，说是网址遭到robots.txt阻止。原来sitemap需要在robots.txt增加配置，于是现在robots.txt如下所示：
User-agent: * Disallow: Sitemap: https://orianna-zzo.github.io/sitemap.xml  要注意的是，如果有网页不想被爬取，不仅需要在robotx.txt中注意增加在Disallow后面，还要注意生成sitemap时不要添加进去。
Bing 相似地，在Bing网站管理登陆、添加网站url。
然后在左侧点击“配置我的网站&amp;gt;Sitemaps”，并在右侧加上sitemap的url，点击提交。
Google基本过一天就能查到，但是Bing我总是很难搜索到，猛然发现上次抓取更新时间还在1-11，已经过了大半个月了，不知道什么时候才能知道效果了。
百度不死心的尝试 百度在这里注册站长管理并添加网站资源，我同样选择添加HTML文件。注意http或者https、www等最好能完全正确。我百度的验证过好几次都没有成功，料想是将https写成了http所以验证出现问题。
在右侧选择“数据监控&amp;gt;Robots”，并点击检测并更新刷新robots设置。
在“数据引入&amp;gt;链接提交”中的自动提交选择sitemap，并提交sitemap地址。
状态转了很久显示抓取失败T^T。
然后选择“数据监控&amp;gt;抓取诊断”，并输入博客网址进行抓取。然后发现，全部都抓取失败了，显示是“拒绝访问”。果然是真的屏蔽了百度爬虫了呀。
Resource资源链接汇总 Google网站管理、Bing网站管理、百度网站管理
版本控制    Version Action Time     1.</description>
    </item>
    
    <item>
      <title>Mac中Git忽略.DS_Store文件</title>
      <link>https://orianna-zzo.github.io/blog/2018-01/mac%E4%B8%ADgit%E5%BF%BD%E7%95%A5.ds_store%E6%96%87%E4%BB%B6/</link>
      <pubDate>Sun, 28 Jan 2018 13:36:28 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-01/mac%E4%B8%ADgit%E5%BF%BD%E7%95%A5.ds_store%E6%96%87%E4%BB%B6/</guid>
      <description>Git中多出来的.DS_Store 虽然不是第一次使用mac，也不是第一次在mac上使用git，但对mac实际上非常不熟悉。每次git上传时多出来的.DS_Store文件虽然不清楚具体做什么，但看上去并没什么问题。git一般也是自己一个人单机使用，就算换机也一般是直接换，没有遇到过两个同时使用的时候，上传.DS_Store也就默认都上传了。
但这次用两个mac，一个mac提交了修改，第二个mac想要拉下来时居然遇到了.DS_Store文件被修改过需要提交再merge。什么？我没改过内容呀？所以这个.DS_Store是什么鬼？
.DS_Store是Mac OS用来存储这个文件夹的显示属性的，被作为一种通用的有关显示设置的元数据（比如图标位置等设置）为Finder、Spotlight用。所以在不经意间就会修改这个文件。而文件共享时为了隐私关系将.DS_Store文件删除比较好，因为其中有一些信息在不经意间泄露出去。
Git中处理方案 方案一：项目设置.gitignore 仅针对git的处理最naive的想法就是设置.gitignore文件。
.gitignore文件用于忽略文件，官网介绍在这里，规范如下：
 所有空行或者以注释符号 ＃ 开头的行都会被 git 忽略，空行可以为了可读性分隔段落，# 表明注释。 第一个 / 会匹配路径的根目录，举个栗子，&amp;rdquo;/*.html&amp;rdquo;会匹配&amp;rdquo;index.html&amp;rdquo;，而不是&amp;rdquo;d/index.html&amp;rdquo;。 通配符 * 匹配任意个任意字符，? 匹配一个任意字符。需要注意的是通配符不会匹配文件路径中的 /，举个栗子，&amp;rdquo;d/*.html&amp;rdquo;会匹配&amp;rdquo;d/index.html&amp;rdquo;，但不会匹配&amp;rdquo;d/a/b/c/index.html&amp;rdquo;。 两个连续的星号 ** 有特殊含义：  以 **/ 开头表示匹配所有的文件夹，例如 **/test.md 匹配所有的test.md文件。 以 /** 结尾表示匹配文件夹内所有内容，例如 a/** 匹配文件夹a中所有内容。 连续星号 ** 前后分别被 / 夹住表示匹配0或者多层文件夹，例如 a/**/b 匹配到 a/b 、a/x/b 、a/x/y/b 等。  前缀 ! 的模式表示如果前面匹配到被忽略，则重新添加回来。如果匹配到的父文件夹还是忽略状态，该文件还是保持忽略状态。如果路径名第一个字符为 ! ，则需要在前面增加 \ 进行转义。  对于一些常用的系统、工程文件的.gitignore文件可以参考这个网站进行设置，这里有很多模板。
针对.DS_Store文件，在git工程文件夹中新建.gitignore文件，在文件中设置：
.gitignore **/.DS_Store  对于已经提交的内容，希望git能够忽略，但同时并不会删除本地文件，需要在terminal输入以下命令：
$ git rm -r --cached $file_path  这个方案的优点就是方便、快捷、最容易想到，缺点就是每个git项目都要重复一遍。</description>
    </item>
    
    <item>
      <title>慢学Docker(2) Docker初探</title>
      <link>https://orianna-zzo.github.io/blog/2018-01/%E6%85%A2%E5%AD%A6docker2-docker%E5%88%9D%E6%8E%A2/</link>
      <pubDate>Sat, 27 Jan 2018 15:04:18 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-01/%E6%85%A2%E5%AD%A6docker2-docker%E5%88%9D%E6%8E%A2/</guid>
      <description>Introduction 什么是docker？ 什么是Docker？Docker是一个开源的容器应用引擎。开发者可以将应用及依赖打包上传到一个可移植的容器中执行，由于容器是可移植的，于是，这个应用就可以在任何其他可以运行这个容器的地方运行了。换句话说，只要其他可以运行docker的地方就可以运行这个容器（因为是可移植的），也就可以运行你的应用，而docker在很多平台都可以安装运行，这样完全不用担心由于平台环境的不同对应用部署带来的困难，更不用提多次部署这种重复劳动的麻烦事了。此外，容器使用了sandbox机制，容器与容器之间有较好的隔离性，不用担心。这是docker最通俗也是最广泛的应用。
是不是觉得这个优点和应用很熟悉？当我们想要跨平台无视底层环境要求跑程序执行应用我们都会想到什么？对，就是虚拟机。在本机上装个虚拟机应用比如说virtual box或者vmware，然后再用操作系统镜像（比如说win7）建个虚拟机，就可以在虚拟机中安装各种应用了。在这里docker就相当于virtual box或者vmware，容器就相当于你建的虚拟机实例，docker中也有一个镜像的概念，就相当于你建虚拟机所使用的操作系统镜像（win7）。这样说是否更通俗易理解一些？
docker容器 vs vm虚拟机 既然虚拟机也可以完成相似的功能，为什么要用docker呢？换句话来问，同样都是虚拟化技术，docker的容器技术和vm虚拟机有什么区别？docker官方网站也简单回答了这个疑问，可以在这里查看。我对于这些底层的架构知识并不是很了解，只能根据网上的信息以及最近这一个月的入门级使用谈及一下感受。
相比vm虚拟机，docker的容器技术更为轻量级。直观上，这个轻量级体现在启动速度更快、占用资源更少。我并没有具体测试比较过，但在实际使用中感受是，我原本开一个虚拟机跑程序就已经很不错了，虚拟机开机还有个等待开机时间，而现在使用docker，容器载入速度很快，同时在机子上会运行几个不同的容器，从镜像重新生成容器也很快很方便。2014年开始，docker一直对外宣传的一个重点也是这个，“虚拟机需要数分钟启动，而Docker容器只需要50毫秒”。
不过docker容器和虚拟机尽管都是虚拟化技术，但是里面的技术细节有很多不同。下面两张docker官网上的图很清晰简单地表示了两者的区别：
前者是虚拟机的架构图，后者是docker容器的架构图。最显然的区别是，每个虚拟机中都运行着各自的guest OS，而在docker容器架构中每个容器只包含了各自的应用和依赖包，并不包含独立的操作系统。也就是说容器采用kernel共享，同时使用cgroups和namespace等方法对容器所使用的命名空间和依赖包等进行区分以达到隔离效果。所以尽管各个容器都是独立在宿主机的操作系统上运行着的，但不可避免地，各个容器之间会共享一些通用运行库。这个区别会使得各个容器之间相互独立，但并没有虚拟机的隔离性好，但这也是使得docker容器能够快速启动并且资源占用少的一个重要原因。太复杂的我也不清楚细节，只是大致有个概念，这对我们简单应用了解也应该就足够了。
嗯，再啰嗦一句。在查资料是看到了这篇知乎上的博文，里面提到在会议SOSP 2017上发表了一篇很有意思的paper，他们通过精简内核和其他虚拟技术把虚拟机做的更轻量级，使之启动速度比docker更快，内存开销比docker更小。现在的热门是容器技术，说不定再过个四五年的又是虚拟机的天下了呢？嗯，说不准是两个结合的究极进化体。门外汉表示看看热闹就可以了。
docker并不万能 Docker真心很好用，才上手了1个多月的我特别喜欢。但是作为新兴技术，还有很多不完善的地方。有些问题可能作为个人使用者来说并不是很大的问题，但是对于生产来说都是非常重要需要考虑的问题，这里只是简单记录下到目前为止遇到的一些局限性，至于其他的，遇到再加吧：
 docker容器主要针对Unix系的，也就是说如果应用是基于windows平台的，现在无法使用docker容器。不负责任地加一嘴，就是没有windows系的基镜像，就像不让你用windows虚拟机一样。 docker本身基于Linux 64bit，也就是说如果你的机子是32位的，暂时无法使用，不过好在现在基本是64位机的天下了，这个问题基本很少遇到。 windows机如果要使用docker，需要支持硬件虚拟化。现在windows版的docker实际上相当于跑了个linux内核的虚拟机。也就是windows不是所有64位机子都能装得上docker的，我新的实习生电脑就装不上，公司的windows笔记本也装不上。 截止目前为止，docker的安装还需要root权限，docker的使用至少需要有sudo权限的用户组。据说容器的使用已经可以不需要root权限了，但我还没有实际使用过。公司服务器一般不会给你root权限，这个需要找运营，折腾起来麻烦。 由于docker的隔离性并不够强，所以docker的安全方面还有待加强。这部分我还没有强烈感受到，反正不影响在自己电脑上折腾。  GPU的选择: Nvidia Docker Docker很好地解决了cpu程序环境依赖问题，但没有解决gpu程序的依赖问题。程序无法可移植地配置gpu环境。为docker配置gpu (nvidia) 环境必须在虚拟环境中安装与宿主环境相同版本的显卡驱动，并手动将显卡设备挂在指定位置。这为gpu程序移植造成困扰。Nvidia在docker基础上进行了封装，解决了gpu依赖问题。如果需要使用gpu，可以安装nvidia-docker。Nvidia-docker安装的前置条件包括docker已经安装、NVIDIA GPU、NVIDIA driver已经安装等，具体条件和安装过程需要查看nvidia-docker的github。
这里只是提一嘴，关注点还是在docker本身。毕竟现在用的mac可用的不是n卡，等有机会整个n卡玩并需要安装docker的时候再试试nvidia-docker。
Installation Docker分为Community (CE) 和Enterprise (EE) 版本，个人使用用CE就够了，一些EE的高级功能用不上也不会用。Docker CE有分为stable版和edge版，前者每一个季度更新一个更reliable的更新，后者每个月都会提供一些新的特征。不爱折腾的我就直接选择stable版。更多关于docker安装的环境需求可以参考官网该页面，不同的环境还是有不同的需求的。
网上有很多零散的安装教程，建议找最新的来看，很多实际上都过时了。最安全的当然直接上官网。
Mac安装 Mac可以选择用Homebrew进行安装:
$ # stable channel $ brew cask install docker $ # edge channel $ brew cask install docker-edge  也可以在这里选择stable或者edge进行下载，安装对应的dmg包即可。
PS，其实还有docker toolbox，暂时还没搞清楚之间的关系，感觉可能是早期版本，官网这里给出了解释，没有仔细看，不过我认为无脑安装docker for mac就够用了。</description>
    </item>
    
    <item>
      <title>慢学Docker(1) Preface</title>
      <link>https://orianna-zzo.github.io/blog/2018-01/%E6%85%A2%E5%AD%A6docker1-preface/</link>
      <pubDate>Sat, 27 Jan 2018 12:32:58 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-01/%E6%85%A2%E5%AD%A6docker1-preface/</guid>
      <description> 初闻 作为一个一向不怎么关心各种资讯动态的人，我经常脱节于前沿新闻及热点，更何况对于非专业方向，我更是不会去主动关心，所以对于之前很火的容器和docker我是一点都不了解。第一次听说这个还是因为前人渣组长李想要求写份标书文档，什么技术热门可用就写进去。他听说了docker容器部署及环境配置的便利性，想利用到项目中的宣传中，更好地作为对外的卖点。不管怎么说，这是第一次听说并尝试了解docker和容器，不过这份了解仅限于网上科技软文宣传，毕竟文档要求紧、内容多，又是全新的概念。
第二次听说docker是带的17届应届生詹辉小仓鼠在公司实验ocr时网上各个项目需要的环境和依赖都有略微不同，比如当时caffe还是基于python2.7，但gpu机子上配的python3环境等问题。还有一个最主要的问题在于，公司的服务器都无法联网，安装环境十分困难。其实连公司的电脑也是无法使用conda、pip等在线安装的，需要离线安装，而且公司电脑标裝windows，配置起来与服务器区别很大。某天小仓鼠过来说docker据说很好用，但是他遇到了些问题，解决后他也认为docker对于环境配置方便了很多。
Docker，你好 决定开始了解docker的契机是换了Mac，有心情来折腾一下电脑和环境，另外由于环境配置和管理的麻烦程度，我又有些强迫症地希望新电脑有一个更干净的环境，于是决定学习一下这个传说中的利器。
这个系列开始于我已经使用docker一个月时间，在正常使用中开始渐渐步入正轨，融入我日常的工作以及学习中来。系列内容中对于docker的介绍可能不会很系统完整，只是对于我的学习过程和应用做一个记录。对于docker一些高级内容和使用方法也可能并不会涉及，毕竟只是“浅尝”、“慢学”罢了。
版本控制    Version Action Time     1.0 Init 2018-01-27    </description>
    </item>
    
    <item>
      <title>/bin/sh vs /bin/bash</title>
      <link>https://orianna-zzo.github.io/blog/2018-01/bin/sh-vs-/bin/bash/</link>
      <pubDate>Mon, 22 Jan 2018 11:20:32 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-01/bin/sh-vs-/bin/bash/</guid>
      <description> 问题背景 这里是一些关于为什么会发现这个问题的碎碎念……
之前也提到我们组的环境有些乱，一些开发机布置在生产，一台有GPU的计算机也布置在生产，如果需要root权限需要找运营，而据我上次和同事沟通结果是木有运营（我觉得应该是他们不知道找谁）。由于没有root权限，不能使用docker，而公司的机子连开发环境都是无法执行pip等操作的，所以只能使用conda创建虚拟环境。
然而，conda创建虚拟环境也需要注意版本问题，比如我手上是没有linux机子的，试验过mac就算conda创建成功也无法搬到服务器上。服务器的linux有以下3个版本，oracle linux6.7, mint 18, centos 6.7，保险起见还是为每个环境都建一个对应的conda环境。
而这个问题就出在mint 18上……
问题内容 我之前建立的docker文件中默认情况是启动 /bin/sh，基本都没有问题，这次也是这样操作。然而在mint 18中，如果在 /bin/sh 中无法使用 source 命令，提示 /bin/sh: 25: source: not found。
问题原因 一开始我还以为是没有安装source命令，但经过查找发现，只要把 /bin/sh 改为 /bin/bash 即可。
原因是，尽管很多linux的 /bin/sh 是建立一个指向 /bin/bash 的软连接（还是会有一些细节不同），但是仍有一些操作系统比如Debian系是用的 /bin/dash ，这两者的区别还是挺大的，但具体是什么我并没有仔细研究。总之以后shell编程如果确认是bash脚本的话还是直接用 bash 比较安全，用 sh 容易发生混淆。
后续 所以，赶紧把dockerfile里的都改为 /bin/bash 了……(2018-03-20 Update)
发现不是所有系统都有bash，因此盲目将所有sh都改成/bin/bash是不行的，最好使用前先了解所用的操作系统。
比如说alpine中用的不是dash也不是bash，而是ash，如果要用bash，需要先下载bash相关包再重建sh-&amp;gt;bash的软连接。可以参考我关于alpine中使用bash的github
版本控制    Version Action Time     1.0 Init 2018-01-22   1.1 Bash is not everywhere 2018-03-20    </description>
    </item>
    
    <item>
      <title>在公司建立python虚拟环境</title>
      <link>https://orianna-zzo.github.io/blog/2018-01/%E5%9C%A8%E5%85%AC%E5%8F%B8%E5%BB%BA%E7%AB%8Bpython%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Thu, 18 Jan 2018 09:14:15 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-01/%E5%9C%A8%E5%85%AC%E5%8F%B8%E5%BB%BA%E7%AB%8Bpython%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</guid>
      <description>前言 尽管官方已经声明python2.7在2020年就不再进行维护，但很多企业应用和第三方包还是建立在python2.7的版本上，进行切换有一定成本。而相比python3，python2对于中文编码处理也相对繁琐的多，因此新的应用一般都会建立在python3上。而python3的版本选择也有分歧，比如说，尽管截止目前为止最新的版本是python3.6，但是链接oracle的包cx_Oracle只在python3.5上成功链接，python3.6上尽管能够安装，但是在实际使用中却无法成功读数。除了python主版本外，所依赖的第三方包版本在不同的应用上可能也会不同。
复杂的版本问题可能在个人开发时并不会有很大影响 (除非有强迫症需要在一个干净的开发环境)，但是当多人需要在同一个开发机/测试机/生产机上跑应用或者模型时，对于各个环境依赖的隔离就急需找到解决方案。依赖隔离问题其实不仅仅在python环境中十分重要，在很多其他程序中也是如此，不过本文还是主要以python环境为主要出发点。
python环境隔离方案 经过网上搜索，目前为止对于python的依赖隔离主要有以下几种主要方法：
 docker virtualenv venv conda  方案选择 docker 其实docker很不错。容器化是现在非常火的一个方案。docker容器崩溃也不会影响主机，而且环境镜像可移植性非常强，能非常方便地把环境移植到不同的主机上去而不需要重新配置安装。现在我自己电脑也尽量在docker中开发，希望能不扰乱电脑本身的环境。可惜的是，尽管网上有信息说新版的docker容器使用可以不使用root权限，也有教程说建立一个可以使用docker的用户组，但是docker的安装还是避免不了需要root权限，而对于公司的环境来说，主机系统环境版本较旧且需要运营安装配置，灵活度不够。（插一句吐槽，其实对于正常有运营的组来说非常正常，但现在新到的组十分不规范，虽然不使用生产数据库但开发机都放在生产环境，其他人都不知道怎么找人root安装软件。）所以在公司使用的场景下只能忍痛放弃。如果没有这个限制，我还是很推荐这个方案，具体使用方法可以参考我另外的docker系列文章。
virtualenv vs venv virtualenv是一个针对python建立定制的虚拟环境的工具，可以在虚拟环境中指定python版本并使用pip安装到激活的虚拟环境中。在使用virtualenv时，虚拟环境会依赖系统环境中的site-packages，可以添加 —no-site-packages 表明虚拟环境不依赖这些包建立一个干净的环境。默认情况下，virtualenv并不会复制一个环境，而是建立一个软连接到现有环境，因此若是需要完全独立的环境，需要添加 —always-copy 来说明。virtualenv存在时间已经很长了，网上有很多相关使用方法。
venv在python3.3之后集成在python标准库中。在python3.4之后可以直接使用venv，而较早版本在venv外包了一层pyvenv，所以很多地方都会提及pyvenv而不是venv，但建议如果允许还是直接使用venv。（注意，pyvenv与pyenv并不同，不要混淆。）尽管一些细节上还是有所区别，venv的实现很大程度上基于virtualenv，因此如果使用python3.3之后的版本，完全可以使用venv替代virtualenv。当然如果你乐意还是依旧可以再装个virtualenv的。
virtualenv vs conda venv相关信息比较少，但因为virtualenv与之相似度很大，就用virtualenv与conda进行比较了。
首先非常重要的一点，venv也好，virtualenv也好都只针对python，也就是无法用在其他语言环境，而conda并不局限于python，它可以管理任何其他语言。我找到一篇关于澄清对conda误解的博文，看完就能对conda有个大致的认识。其中，第5条说明了作者认为conda相比于virtualenv/venv的优点，之后还给出了virtualenv与conda如何结合使用。对我来说最重要的是：conda环境完全隔离，连执行路径都不一致，还有很重要的一点，conda虚拟环境也方便迁移，可以在有外网的电脑生成后打包上传到无网的服务器上使用。这一点就基本决定了要使用conda建立python开发环境。
此外，针对python，Anaconda的文档中对conda、pip和virtualenv进行了简要的比较，其中点明了pip是个包管理器、virtualenv是环境管理器，而conda两者兼顾，还可以升级python核心程序。这个很好地说明了conda的全能。具体对比如下：
   Task Conda package and environment manager command Pip package manager command Virtualenv environment manager command     Install a package conda install $PACKAGE_NAME pip install $PACKAGE_NAME X   Update a package conda update --name $ENVIRONMENT_NAME$PACKAGE_NAME pip install --upgrade $PACKAGE_NAME X   Update package manager conda update conda Linux/OSX： pip install -U pip Win： python -m pipinstall -U pip X   Uninstall a package conda remove --name $ENVIRONMENT_NAME$PACKAGE_NAME pip uninstall $PACKAGE_NAME X   Create an environment conda create --name $ENVIRONMENT_NAMEpython X cd $ENV_BASE_DIR; virtualenv$ENVIRONMENT_NAME   Activate an environment source activate $ENVIRONMENT_NAME X source$ENV_BASE_DIR/$ENVIRONMENT_NAME/bin/activate   Deactivate an environment source deactivate X deactivate   Search available packages conda search $SEARCH_TERM pip search $SEARCH_TERM X   Install package from specific source conda install --channel $URL$PACKAGE_NAME pip install --index-url $URL $PACKAGE_NAME X   List installed packages conda list --name $ENVIRONMENT_NAME pip list X   Create requirements file conda list --export pip freeze X   List all environments conda info --envs X Install virtualenv wrapper, then lsvirtualenv   Install other package manager conda install pip pip install conda X   Install Python conda install python=x.</description>
    </item>
    
    <item>
      <title>Blog养成记(4) Hugo中增加tags等分类</title>
      <link>https://orianna-zzo.github.io/blog/2018-01/blog%E5%85%BB%E6%88%90%E8%AE%B04-hugo%E4%B8%AD%E5%A2%9E%E5%8A%A0tags%E7%AD%89%E5%88%86%E7%B1%BB/</link>
      <pubDate>Tue, 09 Jan 2018 18:22:25 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-01/blog%E5%85%BB%E6%88%90%E8%AE%B04-hugo%E4%B8%AD%E5%A2%9E%E5%8A%A0tags%E7%AD%89%E5%88%86%E7%B1%BB/</guid>
      <description>自定义分类 Hugo是支持用户自定义分类的，这个称为taxonomy，可以来对网页内容进行逻辑划分，详情可以在这里查看。
分类taxonomy有3个概念：
 Taxonomy 分类: 可以用来对内容进行分类的类别 Term 术语: 分类的一个键 Value 值: 分配给这个Term的具体内容  例如我需要增加3个分类，分别是：
 tag：文章标签 topic：文章主题/文章系列 category：文章分类  以tag为例，则对应Taxonomy是tag，Term是具体标签内容比如docker或者hugo，Value是打上这个标签的对应网页。
配置分类 需要在 config.toml 中增加分类。还是这个例子，则需要增加如下内容：
[taxonomies] tag = &amp;quot;tags&amp;quot; series = &amp;quot;series&amp;quot; category = &amp;quot;categories&amp;quot;  而将每个post的头部也相应增加对应的分类，例如这篇的头部就相应为：
date: &amp;quot;2018-01-09T16:22:25+08:00&amp;quot; draft: false title: &amp;quot;Blog养成记(4)增加tags等分类&amp;quot; tags: [&amp;quot;hugo&amp;quot;] series: [&amp;quot;Blog养成记&amp;quot;] categories: [&amp;quot;杂技浅尝&amp;quot;]  当然实际上，Hugo默认会产生 tags 和 categories 的分类，如果只需要这两个，可以不用在 config.toml 中声明就在post头部使用。
分类集合查看 使用分类taxonomy之后，Hugo会使用分类的模板 (taxonomy templates) 来自动生成一个显示所有分类的term术语的网页以及一个显示该术语的所有value内容列表网页。
还是以tag为例：
example.com/tags/ 会列出tags中的所有术语；
example.com/tags/docker 会列出tags标为docker的所有网页列表。
分类排序  分类排序还未正式尝试，无法确认正式效果，还需后面确认后再补充。</description>
    </item>
    
    <item>
      <title>Blog养成记(3) Hugo的语法高亮配置</title>
      <link>https://orianna-zzo.github.io/blog/2018-01/blog%E5%85%BB%E6%88%90%E8%AE%B03-hugo%E7%9A%84%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Tue, 09 Jan 2018 17:52:25 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-01/blog%E5%85%BB%E6%88%90%E8%AE%B03-hugo%E7%9A%84%E8%AF%AD%E6%B3%95%E9%AB%98%E4%BA%AE%E9%85%8D%E7%BD%AE/</guid>
      <description>前言 Hugo官网在这里给出了详细的语法高亮配置说明。
一般有以下3种常见方法：
1. 使用Hugo默认Chroma
2. 使用Pygments
3. 使用CSS
使用Pygments进行高亮 Hugo从0.28版本开始默认使用Chroma来作语法高亮。Chroma使用go编写的，渲染速度很快。 如果需要使用Pygments，需要先安装Pygments，并在网站配置文件中设置一些相关参数。
Pygments安装 我在建立Hugo镜像时已经安装了Pygments，不然需要先安装Pygments。如果在Debian和Ubuntu系统中可以用下面语句安装，其他系统也可参考：
$ sudo apt-get install python3-pygments  Pygments配置 下面是我按官网在 config.toml 中配置的参数：
[highlighting] pygmentsUseClassic = true pygmentsCodeFences = true pygmentsStyle = &amp;quot;autumn&amp;quot;  其中， pygmentsUseClassic=true 说明使用Pygments来进行语法高亮；
pygmentsCodeFences=true 使在code fence中的根据设置的语言标签进行语法高亮；
pygmentsStyle=&amp;quot;autumn&amp;quot; 设置高亮的风格,可以在这里查看各高亮风格，选择最心仪的。
我选择了 autumn，下面是在code fence中的高亮示例：
#!/usr/bin/python3 from engine import RunForrestRun &amp;quot;&amp;quot;&amp;quot;Test code for syntax highlighting!&amp;quot;&amp;quot;&amp;quot; class Foo: def __init__(self, var): self.var = var self.run() def run(self): RunForrestRun() # run along!</description>
    </item>
    
    <item>
      <title>Blog养成记(2) Hugo&#43;Docker在Github上建立Blog</title>
      <link>https://orianna-zzo.github.io/blog/2018-01/blog%E5%85%BB%E6%88%90%E8%AE%B02-hugo-docker%E5%9C%A8github%E4%B8%8A%E5%BB%BA%E7%AB%8Bblog/</link>
      <pubDate>Sun, 07 Jan 2018 11:05:25 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-01/blog%E5%85%BB%E6%88%90%E8%AE%B02-hugo-docker%E5%9C%A8github%E4%B8%8A%E5%BB%BA%E7%AB%8Bblog/</guid>
      <description>Introduction 正如上一篇说的，我选择了Hugo作为静态网页生成器。Hugo是一个用go写的静态网页生成器，它被提及最多的优点就是它生成网站的速度快。此外，Hugo的安装配置看上去也并不麻烦，直接在这里选择合适的版本和环境下载对应release版并配置环境变量即可。整体来说非常方便。
在决定使用Hugo之外，我还决定用Docker来做环境配置。因为新买了mac，不愿意弄乱环境，也希望以后能够跨平台使用，方便配置，更重要的是，最近对docker感兴趣，想实践一下。Docker是一个开源的应用容器引擎，可以方便地将不同容器间的环境进行隔离，但又比虚拟机更轻量化，能更快速启动。与Docker相关的内容我会在另一个Docker系列进行详细说明，这里主要还是与建立Blog相关的使用为主。
网上使用Hugo写blog的内容很多，使用docker的也很多，但使用docker来搭建hugo编写环境并不多，我也是在一步步摸索中。那么，就跟着我一起开始尝试吧！
Hugo的docker环境配置 Docker安装 在Mac中可以使用Homebrew进行安装：
$ brew cask install docker  若是Windows或者其他操作系统，可以在这里选择你的操作系统下载相应版本进行安装并配置环境变量。
获得Hugo开发镜像 我在docker hub上查找了下，截止目前并没有官方镜像，都是用户自己建立并上传的镜像。Hugo的Github中的确有建立docker镜像的Dockerfile，但是我试了几次都未成功，最后决定建立自己的Hugo docker镜像，顺便学习下Dockerfile。
直接获得镜像 如果只想获得开发镜像，可以选择从docker hub上下载个镜像，选择还挺多，欢迎下载我建立的docker镜像，在docker hub中只有32MB，只需要在终端中输入下面的命令即可：
$ docker pull orianna/hugo-docker-dev  该镜像可以在docker hub中找到，点这里是在docker hub上的repo。
接下去在终端输入下面这行命令可以查看你现在有的镜像信息：
$ docker images  你可以发现orianna/hugo-docker-dev只有94.9MB大小.
自建镜像 或者，你可以选择自己建立镜像。如果已经获得了Hugo镜像，可以略过这一部分。
我建立Hugo docker的Dockerfile放在Github上，大家可以去参考试试。现在是v0.3版，只有94.9MB大小的镜像，后续随着开发可能会有新的变化。
将所有内容clone到当前目录：
$ git clone https://github.com/orianna-zzo/hugo-docker-dev.git  打开Dockerfile，其中HUGO_VERSION是Hugo官方的发布版本，可以选择你需要的Hugo版本进行修改。在v0.3的Dockerfile中，定义了两个挂载文件夹，一个是/hugo-site用来挂载你的Hugo源码，另一个是static-site用来定义Hugo生成静态网页的输出文件夹。
除了基础的下载Hugo执行文件和pygments高亮外，Dockerfile还定义了每次打开容器都会执行start.sh。该shell脚本只有一个作用，如果在当前文件夹中包含run.sh文件则执行该文件，若不存在则打开一个终端，在该终端内你可以自由尝试hugo命令。run.sh的作用主要是便于不用反复输入常用命令，可将常用命令直接写入其中保持注释状态，使用时只需要将要使用的命令保持正常状态即可。如果你clone了这个repository，在site-sample中包含了一个样例run.sh。
在这个repo的文件夹中打开终端，输入下面命令以建立镜像：
$ docker build -t orianna/hugo-docker-dev:0.3 -t orianna/hugo-docker-dev:latest .  其中-t给这个镜像打上tag。根据docker hub的要求，非官方镜像的镜像名称需要为你的docker-name/镜像名称，:后为该镜像的tag。-t可以有多个。注意不要忘记最后的.，它表示使用该文件夹中除了.dockerignore 中的其他内容作为建立镜像的上下文内容。
接下去你就可以在终端输入下面这行命令来查看镜像信息：
$ docker images  至此，你已经获得了Hugo的docker镜像了。
尝试使用Hugo 假设您clone了上文提到的内容，可以在该项目中使用下面命令启动容器来试用Hugo docker：</description>
    </item>
    
    <item>
      <title>Blog养成记(1) Preface</title>
      <link>https://orianna-zzo.github.io/blog/2018-01/blog%E5%85%BB%E6%88%90%E8%AE%B01-preface/</link>
      <pubDate>Mon, 01 Jan 2018 16:05:25 +0800</pubDate>
      
      <guid>https://orianna-zzo.github.io/blog/2018-01/blog%E5%85%BB%E6%88%90%E8%AE%B01-preface/</guid>
      <description> 初始  养个Blog的想法从很早就有了，但是&amp;hellip;  从本科开始就一直想要一个自己的Blog，一直没有行动。本身我没有记日记的习惯，也没有需求和冲动写下什么，本科虽然有时想记下学下的内容，但笔记就够了，也没写什么技术博客的想法。除了很久之前偶尔在qq空间或者人人po两篇直抒胸臆的文章，也就没有其他了。此外，虽说博客最重要的是内容，但没有一个好的生态环境和前端界面设计，至少对于我来说，没有兴趣花时间在上面，原谅我还是外观主义者不够geek。当初选择qq空间和人人更多的是为了圈子和分享，记录的因素只占了很少的一部分，让我长久在这上面却不会满意，毕竟这两者的整体环境定位更偏大众。原谅我比较俗气。这就和你发邮件选择@qq.com还是@gmail.com或者@outlook.com感觉一样，后者给予更正式化的感觉，作为邮箱基础功能来说并没有实质性区别。对于界面设计，之前流行的CSDN或者博客园都是简洁风，不够美观现代化，但够用、功能强大、社区用户庞大，不过没让我提起兴趣。自建网站却止步于嫌整套网站建立使用Wordpress太重，嗯，还要租用服务器。我觉得我还要承认，当时作为本科生的我，太过局限于学校课堂，并未出去看看，对于网络信息的运用和挖掘也更多停留在看看答案、找找软件、翻翻视频的基础使用上，最多也就查看下算法之类的。
近几年，特别从研究生开始，越来越多的都是自己查找信息，更多地接触了“世界”的信息和知识，拓宽了视野，也明白本科王建明老师所说的“语言定义了你的范围”这句话的含义。非常感谢导师王文敏教授和在北大的研究生生涯，研究生和本科生的学习方式上差别很多，真正开始“去林子里打鸟”，而这个林子也扩展为“世界的林子”。随着自我学习机会和时间愈多，碎片化学习和感想也愈多，加上虽然网上知识丰富，但内容庞杂，过段时间想再查找却需要对这些信息重新筛选略费时，再加上工作后发现个人体悟有些良多，人老了很多回忆开始忘却，想要记录的心情越发迫切，于是又一次萌生个人博客的想法。
难产  选择恐惧症+控制狂的特质决定了我家Blog的难产&amp;hellip;  尽管现在有很多像知乎专栏这样有现代化的界面和良好的用户群的网站可以让人直接在上面写作发布更关心核心内容，但我还是更倾向于选择Github Pages，与Github非常紧密的关系是该倾向性很重要的原因（这对码农来说很有诱惑力），但仔细想想我的主要原因可能还是由于Github Pages中整个界面设计都可以自己定制，我自认控制欲还是挺强的（虽然界面设计是个头疼的问题）。
Github Pages搭建个人博客，使用的是轻量级的静态网页，网上已经有很多教程和方案。其实去年大约10月开始我就已经开始着手搭建基于Jekyll的博客了。选择Jekyll只是因为它是官方推荐的选择，据说可定制化和功能很强大。尽管对前端框架和ruby都不熟，但由于个人固执，并没有选择简单fork一个theme就安心写博客。我看了官方推荐的好多theme，找了很多自己喜欢的设计和模块，根据自己的需求想进行重新设计和拼接。现在看来，当初界面整体设计有些不忍直视，还需要重新设计。那段时间持续了挺久，下班回去都22点多，却还会打开电脑看看怎么整，不过由于前端我是新手中的新手，很多问题需要好久才能解决并实现设想，后面搭着搭着想把中间遇到的问题和解决方案记下来，下次可以再找，也算记录博客的搭建过程，不过可惜只写了提纲以及最开始的安装部分。这在去深圳出差那段忙碌的日子打断之后再没有捡起来。
重建  过去这么久，干脆重新开始吧！  断了这么久，好多都不记得了，看之前的设计也觉很多需要修改，干脆推倒重来。重来这回就从一开始进行记录，希望这次能够顺利养成。
反正都要重新开始，就想选择更合适的静态网站工具。除了Jekyll外，Hexo是国人教程最多的，国外口碑也非常好，看到外国的一句评论说，缺点就是大多数内容都是中文，英文教程少，哈哈。去年的时候网上就已经很多博客写如何从Jekyll转到Hexo了，其中一个原因是Jekyll用的是Ruby，Hexo是基于Node.js，前者要学liquid，要用css预编译学scss或者less，后者要学js，但后者相对而言对程序员友好些，如果不是特别爱折腾会很繁琐，另一个主要原因说是Hexo的编译速度要比Jekyll快很多。不过这次我决定选择另一个Framework，使用Hugo。Hugo是用现在大热的go语言写的，据说编译起来比Hexo还会快很多。
除此之外，由于新买了Macbook Pro，出于不想弄乱mac的环境可以瞎折腾这个考虑，最近一直在研究docker的使用和最佳实践，于是新的环境搭建希望是基于docker的。就这样开始吧！
版本控制    Version Action Time     1.0 Init 2018-01-01   1.1 增加tag和版本控制 2018-01-17    </description>
    </item>
    
  </channel>
</rss>